"comp1","comp1_expl","comp2","comp2_expl","comp3","comp3_expl","AcademicDegree","ProgExp","ProgExpCompColleagues","Exp_OOP","Years_Prog","Years_ProgLargeProj","coh_Familiarity"
"1","Na primeira classe estão todas as funções necessárias para a conexão com o banco de dados, abertura e fechamento.    Já no segundo código, além da inserção, ela também realiza operações de update. O ideal seria ter duas classes separadas.","1","No primeiro código é possível carregar e salvar as configurações e a classe está limitada a isso.    Já o segundo código possui diversas funções de diferente contextos como por exemplo, identificar o próximo ID disponível na tabela, deletar uma informação, preencher um combo box, etc.","3","Neste caso as duas classes são classes filhas da superclasse Relationship.  Na primeira estão todas as funções para o relacionamento de marido e esposa.  Na segunda estão todas as funções para o relacionamento de pais e filhos.","4","8","4","5","13","4","1"
"1","A classe DB_Backend faz a conexão com o banco de dados.  A classe DB_InsertUpdate de cara já tem duas responsabilidades (inserir e atualizar)","2","Ainda sim, não acho que a classe DB_Helpers possui coesão suficiente.  Em alguns métodos usa String pra referenciar a tabela e em outros métodos utiliza um DefaultModel.    A classe Main_Config2 está longe de ser uma classe com coesão. Possui informações do hotel e ainda faz o controle das reservas de forma procedural.","2","A classe RelationSpouse contém um método printToFile que não tem nada a ver com o propósito da sua própria classe.","2","8","3","5","5","4","1"
"1","DB_Backend não faz referência para DB_InsertUpdate, enquanto o inverso é verdadeiro. DB_InsertUpdate depende de DB_Backend para implementar suas funcionalidades   Exemplo de dependência em DB_InsertUpdate: DB_Backend.getConnection().createStatement();","1","Main_Config2 apresenta um menor número de funcionalidades e dependências em relação à DB_Helpers.","3","As classes possuem funcionalidades e dependências similares.","5","8","4","5","8","2","1"
"3","Creio que as duas sejam bem específicas para as funções que realizam.","1","Eu achei a primeira mais coesa uma vez que faz a tarefa específica de configuração. A segunda tb é específica de banco, mas realiza operações de consulta e deleção. Creio que poderia ser mais coesa.","1","Tem um método na RelationSpouse (printToFile) que poderia ser extraído para uma classe específica pra ficar mais coesa","3","8","4","3","6","4","1"
"3","Para mim possuem o mesmo nível de coesão pois cada uma tem um único objetivo e seria complicado separar os métodos de cada classe.","1","Porquê a classe Main_Config2 é mais específica... A segunda classe pode ser dividida em mais de uma para que fique bem específica, da maneira atual tem métodos de objetivos diferentes.","3","São bem objetivas e tem um comportamento específico.","3","9","4","4","6","4","2"
"3","Acredito que apesar da segunda classe implementar dois comportamentos (Incluir e Atualizar) esses comportamentos ao meu ver pertencem a um unico modulo.","1","A classe DB_Helpers implementa muitos comportamentos que podem ser entendidos como modulos separados","2","O comportamento print to file poderia ser facilmente implementado em um Visitor especifico para impressão em arquivo.","2","8","5","5","4","2","1"
"1","A segunda classe que seria utilizada apenas para realizar insert e update também é utilizada para concatenar os valores do array em uma string. A primeira classe na minha análise (não conheço mysql) é utilizada para gerenciamento da conexão (abrir, fechar, verificar se está aberta a conexão, etc).","3","A primeira classe apenas realiza a leitura do arquivo e possui os métodos de get e set nas propriedades de configuração do sistema, enquanto a classe 2 possui apenas métodos genericos relacionados a banco de dados.","3","As classes foram construidas com o mesmo nível de coesão, pois todas as verificações relacionadas a pessoa são realizadas na classe especifica (Person)","2","8","4","4","5","3","1"
"1","Embora o nome da classe DB_InsertUpdate indique uma composição de 2 operações (insert e update), e portanto, o que deve estar dentro dela é justamente operações para inserção e atualização, a coesão funcional parece negligenciada, pois inserção e atualização são 2 tarefas que endereçam problemas distintos.  Eu diria que há uma coesão comunicacional, onde os dados de entrada/saída são compatíveis (os mesmos).","3","se considerarmos um contexto mais abrangente (funçòes diversas de gerenciamento de dados no banco) temos algum grau de coesão, embora não haja coesão funcional. ambas as classes se enquadram neste contexto mais abrangente.","2","Embora a impressão no arquivo para a classe RelationSpouse se refira aos seus dados, este método de impressão poderia ser delegado para outra classe (específica para impressão).","4","5","3","4","22","0","1"
"3","Classes com funções bem definidas.","1","A segunda classe possui mais funções.","3","Classes com objetivos bem definidos.","2","8","2","3","5","3","1"
"1","Resposta curta e mais correta: feeling.  Resposta longa e menos correta:  A primeira classe tem uma responsabilidade bem definida, que é gerenciar conexões com o BD, e não precisa de informações das classes que farão uso dela.  Já a segunda classe possui uma responsabilidade difícil de definir e faz suposições frágeis a respeito dos módulos que farão uso dela, como o modelo do BD.","1","Novamente, esses helpers são difíceis de definir sua funcionalidade e fazem suposições a respeito dos módulos que fazem uso da mesma (formato da query, modelo do banco, etc.). Sem falar que realiza coisas que não são de sua responsabilidade, como tratar exceção do banco, se é uma classe ""helper"" ela não tem informações suficientes pra entender o que aconteceu... por exemplo, quem disse que o erro deve gerar uma mensagem e não é um erro ""esperado""?","1","Não me parece apropriado colocar a responsabilidade de gravar em disco na classe RelationSpouse. Nesse caso ela possui mais de uma responsabilidade e por isso é menos coesa.","4","9","4","3","10","7","1"
"1","The query builder should be in a different module/class and not inside the DB_InsertUpdate class.","3","Both classes lack cohesion. DB_Helpers is both specific and generic. Having the  method getNextID which is generic while is specific to query specific tables in DB. It should be separated.     The Main_Config should not load and store the infos form config file. It should be done by 2 different classes. One to store info and a second one to load it from the config file.","2","RelationSpouse was suppose to be a relation only class but it includes a JPanel reference. Not cohesive at all.","2","9","4","5","5","4","1"
"1","Apesar dos nomes das classes não serem muito adequados, a classe DB_Backend tem uma única responsabilidade. A de manter um pool de conexões (erroneamente implementado, mas...).     Já a classe DB_InsertUpdate em a responsabilidade de inserir e alterar toda e qualquer tabela no banco.. o que me parece uma responsabilidade muito ampla..     Caso você considere a responsabilidade da segunda seja exatamente esta. Alterar todas as tabelas do banco.. poderia-se pensar que ela é coesa.. Mas isto varia de pessoa para pessoa","1","Nem olhei direito a segunda, mas ela tem misturado componentes gráficos e acesso a banco de dados. Isto é, tem que se preocupar com muita coisa.. cria uma acoplamento que não deveria existir.","3","Na minha opinião nenhuma é coesa, num ponto de vista de design. Isto é, a classe Pessoal deveria mantar estes relacionamentos.      Além disto, mesmo motivo da questão anterior.. a primeira classe se preocupa com a responsabilidade dela e mostrar coisas na tela..","4","9","5","5","13","11","1"
"1","DB_Backend seems to be more cohesive. It has some shared data(attributes) compared to DB_InsertUpdate. There are no attributes at all and all methods are static and work independently.  Offtopic: I am not quite sure, but it seems to me that DB_InsertUpdate might be vulnerable against sql-injection.","1","Maybe I am doing something wrong. But it seems to me like the previous case. Cohesion in MainConfig2 due to presence of shared attributes and all methods in DB_Helpers are static.","2","My decision is influenced by the method printToFile in RelationSpouse. I don't think this class should be responsible for writing data.","4","9","5","5","12","4","1"
"1","A classe DB_Backend realiza operações apenas de comunicação com o banco de dados. Já a classe DB_InsertUpdate realiza duas operações, inserir e atualizar. Para a segunda classe ser mais coesa, ela teria que ser dividida em duas: DB_Insert e DB_Update","3","Ambas possuem baixo nível de coesão. Para obter uma maior coesão, a primeira Main_Config2 deveria ser dividida em duas classes uma para os gets e outra para o sets.  A segunda, DB_Helpers possue diversas funcionalidades que deveriam ser distribuídas em mais classes. Por exemplo, ""Returns the number of rooms in the database"" deveria estar em uma classe separada. O mesmo para ""Returns the number rooms in use at the specified date d"" e outros métodos.","2","A classe RelationSpouse possui baixa coesão e deve ser divida em mais classes, como por exemplo o método ""printToFile"" deveria estar em outra classe.","4","7","3","3","5","3","1"
"2","A segunda classe tem métodos mais claros, legíveis e tem uma complexidade muito menor. No caso da primeira classe é possível subdividir os métodos tornando mais coesa a classe.","3","As classes tem propósitos diferentes o que a meu faz com que a comparação entre elas não seja direta, mas as duas parecem semelhantes respeitando seus objetivos.","3","Para mim as classes são tem objetivos similares, ambas implementações são parecidas. Isso faz com que a coesão seja parecidas também.","2","7","3","5","5","2","1"
"1","Na primeira classe os métodos utilizam atributos internos.  Isto não ocorre na segunda classe, que facilmente poderia ser decomposta em mais partes.","1","A primeira classe contém vários métodos que ocupam diversos atributos e outros métodos da própria classe. No caso da segunda classe, isto não ocorre e esta poderia ser decomposta em mais classes.","2","As duas classes são muito semelhantes, usando atributos e métodos internos.   No entanto a classe RelationSpouse contém um método (ou um comportamento) que poderia, talvez, ser separado desta classe (método printToFile).   A classe RelationParentChild não inclui este comportamento de imprimir para um arquivo.","2","4","3","3","8","0","2"
"3","Verifiquei que as responsabilidades das duas classes estão bem definidas e nas mesmas possuem rotinas que apenas atendem ao que define a responsabilidade de cada uma.","2","A primeira classe possui rotinas que não são exclusivamente ligadas a carregar configurações de um arquivo. A classe acabou absorvendo informações de acesso ao banco de dados.","2","A primeira classe além de representar o relacionamento entre marido e mulher possui métodos que não estão ligados a esta atividade, por exemplo, o método printToFile.","3","9","3","5","6","6","1"
"1","A classe DB_Backend possui apenas a responsabilidade de abrir e fechar conexões. A segunda, apesar de genérica, está concentrando duas funcionalidade que não tem nada em comum: inserir e atualizar registros.","1","A classe DB_Helpers foi alimentada com a velha preguiça de fazer um modelo legal para resolver o problema. Pode ter ate começado com boas intenções (talvez métodos como getNextID) mas depois começou a adicionar diversas funcionalidades que poderiam estar mais bem separadas (exemplo:  getNumberOfRooms) Cade a classe Hotel por exemplo? Que teria o numero de  quartos disponiveis em vez de colocar em um Helper.","3","Ambas cuidam de relacionamento entre duas entidades e cada uma com seus próprios critérios.","1","10","5","5","10","10","1"
"3","A primeira classe trata do gerenciamento das conexões. E a segunda da inserçaõ e atualziação dos dados utilizando a primeira classe.","1","A primeira tem uma responsabilidade mais definida. Asegunda é muito genérica e trata de muitas responsabilidades.","2","A segunda é mais coesa, proque a prmeira trata da impressão em arquivo que não deveria ser de sua responsabilidade.","4","8","3","3","29","5","1"
"1","A classe de backend não precisa de outras classes para gerenciar a conexão com banco. Já a classe InsertUpdate sempre precisará da classe Backend para inserir e atualizar dados no banco de dados. Logo existem funcionalidades de InsertUpdate que não estão contidas na mesma, ao contrário da classe de Backend. Por isso, a segunda é mais coesa.","1","Estou considerando que a classe de Helpers possui métodos variados, que não correspondem à uma funcionalidade coesa, e sim várias funcionalidades diferentes. Já MainConfig possui a funcionalidade de gerenciar arquivos de configuração, sendo na minha opinião, mais coesa.","3","Elas possuem métodos similares/equivalentes, que gerenciam um determinado relacionamento entre parentes de uma árvore genealógica.","4","7","4","4","6","2","1"
"3","Usei a definição de Steven et al., 1974: ""em um módulo altamente coeso, todos os seus elementos estão relacionados para a realização de um único comportamento do software."" Em minha opinião as duas classes tem alta coesão.","3","Ambas são classes utilitárias, com variedade de métodos para servir outras classes.","3","As duas classes tem a mesma lógica e implementa suas soluções da mesma maneira.","4","8","3","4","10","5","1"
"3","As duas estão designadas para mapear a mesma funcionalidade: persistência de dados","1","A primeira classe só executa funções ligadas a ler e carregar um arquivo de configuração, porém a segunda realiza diversas funções diferentes, apesar de serem com o mesmo fim, mas que vão de encontro ao de que uma boa coesão se dá quando é assumida somente uma responsabilidade","2","a primeira classe assumiu mais responsabilidades, como imprimir e tratar erros, além de apresentar a relação entre marido e mulher, por isso acredito que ela é menos coesa","2","7","3","3","4","2","1"
"3","O meu raciocínio foi que as duas classes tem a mesma quantidade de responsabilidades, a classe DB_Backend gerencia conexões com o banco de dados, conectando e desconectando com o BD, enquanto a classe DB_InsertUpdade grava dados no banco de dados, inserindo ou atualizando informações.","1","A classe Main_Config2 tem o papel bem definido de gerenciar as propriedades de configuração do sistema. Já a classe DB_Helpers, apesar de ter diversos métodos relacionados ao banco de dados, são métodos que não tem o mesmo sentido, por isto esta classe não tem uma função bem definida no sistema, o que a torna uma classe com baixa coesão.","2","A primeira classe além de representar o relacionamento entre marido e mulher também mostra os relacionamentos em uma interface gráfica, enquanto a segunda classe apenas representa o relacionamento entre pais e filhos.","2","5","3","3","6","1","1"
"3","a classe DB_Backend, é implementado apenas o que é destinado a classe, e a classe InsertUpdate recorre a classe DB_Backend para obter conexao para realizar suas operações, não implementando a conexao ao banco que seria necessaria em sua própria classe.","2","a classe DB Helpers faz apenas o que se propões que é métodos para acesso a banco de dados mantendo sua coesao, a classa Main_Config2, além de obter dados de configuração do sistema, busca informações que nao tem essa finalidade, tais como: endereco do hotel,fax, telefone etc.","3","as duas classes trata apenas do que se propõe.","2","8","4","4","8","7","1"
"3","As duas classes possui a sua função específica e executa o que foi determinado.","1","A segunda classe é responsável por diversos métodos com diferentes funções, assim a classe perde a coesão.","3","Cada uma classe executa métodos específicos.","3","4","3","3","1","1","1"
"1","If you analyse it carefully, and with some metrics, you could say that the Backend is more cohesive than InsertUpdate, as the second can be split into Insert and Update.  However, this is not a problem if the sw is like this. There is a reason why INsert and Update were put together and it does not affect the maintenance of the sw in a negative way.","2","MainConfig2 is grouping the application proprieties, while DB_Helpers is mixing database operations with interface.","2","RelationSpouse mixes domain concepts with printing it to a file.","2","9","4","5","11","7","1"
"1","A primeira classe é responsável por uma unica tarefa, que é a conexão.","1","A primeira esta bem definido a sua função de carregar as configurações, enquanto a segunda deixa ""aberto"" que possui diversas finalidades, podendo realizar diversas tarefas distintas.","3","Ambas fazem a mesma tarefa que é de verificar o relacionamento entre duas pessoas.","2","8","4","4","5","3","2"
"2","A classe DB_Backend possui muitos métodos publicos que expôem seu funcionamento interno. Já a classe DB_InsertUpdate somente possui em sua interface os métodos especificos para o uso da mesma, e executa somente as tarefas que seu nome sugere.","1","A classe DB_Helpers mistura conceitos, possui métodos que são especificos para a entidade ""Room"" quando deveria possuir somente métodos genericos para ajudar nas operações com banco de dados. Isso pode se tornar um problema na manutenção se existe alguma outra classe que se encarrega de salvar, alterar e apagar dados com relação a entidade ""Room"".  Já a classe Main_Config2 de fato se encarrega somente em carregar e prover acesso as configurações gerais do software.","2","A classe RelationSpouse possui método para a serialização em arquivo. Isso deve ser evitado pois a serialização deve ser algo ortogonal a classe que representa uma entidade, e independente de método (arquivo, banco, stream).  Já a classe RelationParentChild se resume somente a representar esses dados e ter metódos para comparação (se é igual etc.) e manuseamento da entidade, o que é bastante consistente.","2","9","4","4","10","7","1"
"3","Levei em consideração o domínio que foi atribuído a cada classe e quais as ações que cada uma delas executava em seu código, assim avaliei se o comportamento de cada uma delas estava de acordo com o que lhe foi proposto.","1","Uma vez que a classe DB_Helpers apresenta métodos com nomenclaturas específicas de outro domínio que não tem a ver com comportamentos de um banco da dados.","2","a classe RelationSpouse assume comportamentos não relacionada ao relacionamento entre marido e mulher, como por exemplo a responsabilidade de gerar um arquivo.","2","5","3","4","24","3","1"
"3","O método DB_InsertUpdate.update é praticamente replicado e pode ser refatorado. O mesmo ocorre com o método DB_Backend.connect_DB.  Por essa análise superficial, considerando que cada classe tem um método repetido, julgo terem o mesmo nível de coesão.","1","A classe DB_Helpers é muito dependente de elementos da interface gráfica (Swing). Além de controlar o BD, ela insere elementos em listas e combos da interface Java. Isso implica em baixa coesão da classe.","2","A classe RelationSpouse usa elementos da interface gráfica do Java, o que não deveria ocorrer para se alcançar uma alta coesão. O mais adequado seria lançar exceções e os componentes da interface gráfica fazerem o tratamento das mensagens.","2","9","4","4","12","5","1"
"1","The first class provices a single type of service: database connection management. For this reason, it becomes difficult to split methods that open a new connection and close existing connections into different classes.    The second class, in turn, is less cohesive as it aggregates services that could be split into different classes without creating redundant code across the classes.","1","The first class is solely related to configuration management (retrieving options from a config file, and saving back any changes).    The second class seems a real mess: although the name of the class is DB_Helpers, most of the services in it do not seem to me mere helpers; for example, there are methods for checking if rooms can be deleted which are more related to the business rules of the system (rooms cannot be deleted if they are booked), than to the manipulation that should be done in the DB in order to get the work done.","2","The first class includes a method that does not have any relationship with the information the class must maintain in the system: printToFile.","4","8","4","4","11","3","1"
"3","A primeira só cuida da conexão com o banco. A segunda só faz as ações relacionadas a persistência, sem se preocupar com a conexão com o banco.","1","DB_Helpers possui métodos relacionados a outras coisas além de prover métodos diversos de acesso ao banco de dados.","2","RelationSpouse tem outras coisas além da relação marido e mulher como o método de imprimir.","3","9","4","5","5","5","1"
"1","A primeira classe é mais coesa. Embora os métodos de conexão pudessem ser agregados em um só, eles executam uma mesma responsabilidade para a classe: conexão com o banco de dados. No caso da segunda classe, é possível dividi-la em duas novas: uma responsável pela inserção de novos registros no banco de dados e outra que cuide da atualização de registros já existentes.","1","O raciocínio é similar ao da questão anterior. A segunda classe acaba desempenhando muitas funções dentro de um mesmo contexto o que poderia ser dividido em novas classes ao passo que a primeira cuida de apenas uma operação.","3","No meu entendimento, as classes são similares. A única diferença é que atuam em domínios diferentes (homem-mulher e pais-filhos). Por essa razão, considero a coesão como sendo a mesma para elas.","2","9","4","4","10","6","1"
"1","Se olharmos ao propósito de casa uma das classes, então elas são igualmente coesas, pois o propósito de cada uma é bem claro e distinto. Se olharmos à estruturação das classes tendo em vista a reutilização de métodos dentro da própria classe, então a primeira classe, (DB_Backend) é mais coesa, pois na segunda classe (DB_InsertUpdate) existe bastante código repetido que poderia ser isolado em métodos reutilizáveis.","1","Segui o mesmo raciocínio que segui na questão anterior.","3","Se olharmos ao propósito de casa uma das classes, então elas são igualmente coesas, pois o propósito de cada uma é bem claro e distinto. Se olharmos à estruturação das classes tendo em vista a reutilização de métodos dentro da própria classe, então elas são igualmente coesas, pois não considero que poderia ser alcançado um nível mais alto de reutilização dos métodos dentro da própria classe.","4","6","2","3","4","2","1"
"1","A classe de DB_BackEnd, tem uma responsabilidade única, ela manipula as conexões do banco, no entanto a DB_InsertUpdate é responsável por inserir e editar registros, sendo assim, ela possui menos coesão, já que possui mais responsabilidades.","1","A classe DB_Helpers se parece com uma classe utilitária, no entanto além de oferecer métodos comuns às operações de banco, ela também possui algumas regras de negócios relacionadas às reservas e aos quartos do hotel.","2","A classe RelationParentChild é coesa pois ela só atende aos interesses da relação entre pais e filhos. A classe RelationSpouse não apresenta coesão visto que além de tratar da relação do casal ela também exibe mensagens de interface gráfica e faz output para um arquivo.","2","6","3","3","5","3","1"
"1","DB_InsertUpdate realiza duas operações (insert e update). De acordo com o conceito de coesão da página anterior, a classe DB_Backend é mais coesa pois realiza apenas a conexão com o banco de dados.","3","As duas classes não são muito coesas, pois realizam várias operações referente a diferentes conceitos.","2","RelationSpouse contém a operação de escrever em arquivo que poderia ser uma classe separada, se tornando mais coesa.","2","7","4","4","7","6","2"
"3","Both classes execute only functions regarding their own responsibilities, i.e., the DB_Backend does only handles the database connection, while the DB_InsertUpdate does only insert and update data by using the connection provided by the DB_Backend class.","3","Nenhuma das classes me pareceram suficientemente coesas por misturarem elementos de acesso ao Banco de Dados (e.g., porta, host, password), controle de reservas (e.g., invoice) e controle de quartos (e.g., numero de quartos disponíveis)","3","Ambas as classes realiza funções relativas à relação, e não à esposa ou ao filho especificamente, como pode parecer em um primeiro momento.","4","7","3","4","9","1","1"
"3","A classe DB_Backend trata apenas da conexão com o banco de dados, cria a conexão, fornece um método para retornar esta conexão, além de finalizar a conexão ao banco. A classe faz exatamente o que se propõe.    A classe DB_InsertUpdate apesar de não ser muito elegante por utilizar substrings para compor clausuras SQL (minha opinião) é também tão coesa quando a DB_Backend, faz exatamente apenas o que se propõe, insere e atualiza dados no banco.    Como fiz esta investigação? Primeiro verifico a assinatura e nomes dos métodos, tento identificar do que se trata e se estão no lugar onde deveriam, após verifico o conteúdo do método tentando identificar se o nome está de acordo com a implementação.","1","DB_Helpers possui métodos sem relação um com o outro, como método para calcular próximo ID de uma tabela e métodos para consultar informações sobre quartos por exemplo.","2","o método RelationSpouse.printToFile() poderia ser movido para outra classe especializada em tratar saída dos dados, deixando a classe RelationSpouse mais coesa.","2","9","4","4","11","6","1"
"1","According to the definitions in the previous section, I would say that the DB management class is more cohesive because it basically handles a single responsibility. In the Insert/Update class, we could split the class in two, as the elements are related to the performance of a different behaviors of the software.","1","The DB_Helpers class deals with different concerns, as it mixes generic methods to handle the database with methods to check whether a room is deletable, for instance. On the other hand, Main_Config2 is only concerned with loading, saving and managing the configuration properties.","2","I picked RelationParentChild only because RelationSpouse has an additional method for printing the relationship to a file at the end that did not need to be in the class.","4","8","4","3","15","0","1"
"1","Segundo a definição anterior, uma classe muito coesa possui uma única responsabilidade. O nome da segunda classe já sugere que ela tem duas responsabilidades (inserir e fazer update). Na primeira classe, a responsabilidade parece ser uma só: gerenciar conexões. Apesar de que poderia ser vista como três responsabilidades: abrir,fechar, e pegar conexão. Mas todos os métodos compartilham variáveis em comum, parecem estar bem relacionados, então eu diria que é só uma responsabilidade.","3","Eu achei as duas classes com pouca coesão. A primeira, Main_Config2, que deveria focar só em ler e salvar as configurações de um arquivo, expõe mais comportamento através dos métodos públicos get e set para cada atributo. Dessa forma um cliente pode usar essa classe para outras funções além de ler ou salvar as configuração de um arquivo. Pode definir as configurações diretamente com os métodos gets e sets. A segunda classe possui vários helpers que só tem em comum a relação com o banco de dados. Mas alguns helpers são gerais, como o delEntry, outro são específicos de uma tabela, como o isRoomDeletable. Acredito que essa classe poderia ser dividida melhor. Talvez uma classe responsável pela tabela com informações dos quartos. Outra classe utilitária mais geral.","2","Eu acho que a primeira classe RelationSpouse possui um método printToFile que deveria ser responsabilidade de outra classe, por isso, acho ela menos coesa que a segunda.","4","7","4","4","9","2","1"
"1","Porque a segunda classe talvez acumule mais responsabilidades do que deveria","2","Achei que as responsabilidades da segunda classe são mais bem definidas do que na primeira","4","não consegui definir qual das duas classes foi mais coesa","3","8","4","4","8","5","1"
"1","A segunda classe trata de conexão efetiva com banco e controle de conexões, logo assumindo duas responsabilidades que poderiam ser definidas em classes diferentes.","2","Executa diversas responsabilidade, como:  - Buscar o próximo id livre de uma tabela;  - Deletar um registro de uma tabela;  - Procurar por quartos livres em uma data;  etc","2","A primeira tem uma responsabilidade de gravação em arquivo que não deveria ser atribuida à classe.","4","8","4","4","20","8","1"
"3","Eu avaliei os métodos públicos providos pelas classes e o quão eles estão relacionados com a responsabilidade de cada classe, a qual inferi pelo comentário descrevendo cada classe.    Desta forma, cheguei a conclusão que em ambos os casos os métodos públicos estão relacionados com a responsabilidade de cada classe.    Além disso, usei como auxílio a definição anterior de que uma classe altamente coesa é indivisível.","1","Novamente, segui a heurística de ler a responsabilidade de cada classe e verificar se os métodos públicos de cada classe estavam ou não relacionados com a responsabilidade da classe.    Desta forma, identifiquei que para a classe DB_Helpers há uma série de métodos que realizam responsabilidades bastante distintas: alguns atuam diretamente no banco, outros em elementos da interface, por exemplo. Por isso considerei DB_Helpers menos coesa.    Além disso, eu empreguei novamente o conceito de que classes altamente coesas são indivisíveis. Desta forma, julguei que DB_Helpers poderia ser quebrada em uma classe contendo métodos auxiliares que atuam na camada de acesso ao banco de dados, e outra classe contendo métodos auxiliares que atuam na camada de apresentação.    obs.: Não considerei os métodos getters e setters na análise de coesão.","2","Novamente, comecei buscando as responsabilidades de cada classe, mas desta vez peguei as responsabilidades do próprio enunciado da questão, não dos comentários.    Pela própria definição das responsabilidades, identifiquei que havia definição de mais de uma responsabilidade, o que me soou logo de cara como um sintoma de baixa coesão.    Analisando o código fonte, percebi que a classe RelationParentChild implementa apenas a lógica relacionada ao relacionamento entre pessoas, enquanto a classe RelationSpouse implementa a lógica relacionada ao relacionamento entre pessoas e também as lógicas de salvar no arquivo e exibir na interface gráfica mensagens.     Seguindo a sugestão inicial de que uma classe altamente coesa é indivisível, julguei que RelationParentChild é mais coesa do que RelationSpouse, visto que RelationSpouse poderia ser quebrada em três classes: uma para representar a lógica da relação entre pessoas, outra para a exibição de mensagens na interface gráfica  e outra para a persistência em arquivos.","4","8","4","5","9","2","1"
"1","The first class joins all responsibilities regarding a databased connection. On the other hand, the second class brings information that could be split into more than a single class, e.g., a class handling inserts and another handling updates.","3","The amount of different accessor methods (getters/setters) in the first class led me to consider this as a low cohesive class. Those methods deal with several purposes. It is better to have several getter/setter classes, that join similar responsbilities, than having a &quot;global&quot; one, that joins accessors to all entities in the project.    The same problem is faced in the second class. It doesn't have a single and well-focused objective.","2","The first class has a method that doesn't have to do with its main purpose, but rather to &quot;print&quot; things, that indeed could serve to more than this single class and, as such, could be considered as a separate entity. This problem doesnt happen to the second class, that only involves things related to its main purpose.","4","7","4","4","8","0","1"
"1","A opção foi escolhida principalmente porque a segunda classe contém várias conexões com a classe que realiza o backend. Tais ações são relativas a uma funcionalidade que é necessária para o funcionamento da classe DB_InsertUpdate, mas que não faz parte da funcionalidade da classe.","1","A segunda classe possui acoplamento com diversas outras classes. Dessa forma, a coesão da classe diminui já que existem vários outros elementos que não fazem parte da implementação da funcionalidade principal da classe","3","Ambas as classes possuem o mesmo nível de coesão nesse caso apesar da forma de implementação/verificação das relações entre os objetos","4","8","4","5","14","6","1"
"1","de acordo com a definição dada, a classe DB_InsertUpdate pode ser dividida em outras classes mas a Backend teria mais dificuldade em ser dividida","1","pelos mesmos motivos apresentados anteriormente","3","acredito que o nível de dificuldade em dividar as duas classes é o mesmo","3","8","4","4","15","8","1"
"1","A primeira classe tem como única responsabilidade a conexão com o banco de dados. A segunda classe, possui como responsabilidade insert e update e é mais fácil de dividir em duas classes diferentes. Como foi mostrado na página anterior, Bieman e Kang (1995) declarou que uma classe altamente coesa deve ser difícil de dividir em duas ou mais partes. Tomando isso como base, a primeira parece ser mais coesa do que a segunda classe.","1","A primeira classe tem como responsabilidade fazer o load e o save de configurações. Enquanto a segunda classe mistura um pouco as responsabilidades, por exemplo, os métodos isRoomDeletable e getComboItems não parecem estar realizando atividades de um mesmo contexto.","2","A classe RelationSpouse possui o método printToFile que não deveria fazer parte desta classe para que a coesão fosse mantida mais alta.","3","9","5","5","7","6","1"
"3","The fields from both classes are similiar regarding the behavior of each class.","1","The fields from the first class are similiar regarding the behavior of this class (more similar than those from the second class).","3","The fields from both classes are similiar regarding the behavior of each class.","4","6","2","3","16","0","2"
"1","A primeira classe é uma classe utilitária para conectar e desconectar do banco. A segunda classe poderia ser dividida em duas, uma para inserções outra para atualizações.","3","Os atributos e métodos das duas classes não tem tanta relação uns com os outros","3","As duas classes são iguais","2","9","4","3","11","7","2"
"1","Levando com consideração a definição mostrada no passo anterior (""uma classe coesa se mostra difícil de ser fragmentada em outras classes""), eu vejo a DB_Backend como mais coesa que a DB_InsertUpdate, apesar de a classe de conexão ser maior, e portanto correr maior risco de lidar com diferentes responsabilidades. Essa ideia foi derrubada através de uma análise do código, quando cheguei à conclusão de que os métodos de conexão ao BD seria muito mais dificilmente fragmentados em diferentes classes do que os métodos de Inserção e Update de registros, presentes na classe DB_InsertUpdate.","1","Apesar de apresentarem a mesma ""dificuldade"" em fragmentação em uma possível refatoração, a classe Main_Config2 parece ter mais sentido por concentrar as funcionalidades que concentra, principalmente pelo conjunto de gets e sets","2","A classe RelationSpouse tem como objetivo definir os atributos e métodos relacionados à husband e wife, com adição da funcionalidade de escrever em arquivo. A funcionalidade de I/O parece ser mais facilmente realocada em uma outra classe, se comparado a qualquer método da classe RelationParentChild","2","6","3","4","5","0","1"
"3","As classes tem o mesmo nível de coesão por que fazem o que a ti é responsável, também a implementação da InsertUpdate não seja a melhor, mas a sua classe tem a responsabilidade que a faz executar os processos.","1","A segunda classe executa procedimentos que não deveriam ser feitos, por exemplo queries para insert.","2","a primeira tem regra de negocio que nao deveria pertencer a ela","2","3","2","3","5","0","1"
"4","Não sei o suficiente sobre coesão para conseguir perceber qual tem o maior nível de coesão :(","4","Não sei o suficiente sobre coesão para conseguir perceber qual tem o maior nível de coesão :(","3","As duas são bem parecidas e todos os atributos estão lá possuem uma única responsabilidade (como definido no inicio da pesquisa)","2","7","3","4","7","6","2"
"1","Levei em consideração o objetivo, responsabilidade, da classe. A primeira classe tem o único objetivo de gerenciar a conexão.","1","A forma como a primeira classe foi mais estruturada que a segunda, deixando a classe mais simples de entender.","3","Achei as classes muito parecidas.","2","7","3","4","5","3","1"
"2","A principio, a classe DB_Backend possui duas responsabilidade: gerência do pool e estabelecimento/encerramento das conexões. Dessa forma, reutilizar a gerência de pool para outras finalidades ficaria prejudicado.","1","A principio a classe DB_Helpers é uma classe que contém os métodos que não encontraram seu devido lugar no sistema :) Consequentemente, a coesão fica prejudicada.","2","A classe RelationSpouse utiliza os recursos de apresentação do Swing, portanto é menor coesa pois sua reutilização em outras tecnologias de apresentação ficaria prejudicada.","4","9","5","5","25","12","1"
"1","Porquê DB_InsertUpdate depende de DB_Backend, mas DB_Backend não depende de DB_InsertUpdate.  Assim, DB_InsertUpdate deve estar sempre acoplada a DB_Backend, o que diminui a coesão.","3","As duas classes são bastante coesas e têm poucas dependências para outras classes do software, sendo dificilmente quebradas em classes menores (o que geraria muitas dependências entre as novas classes formadas)","3","Ambas dependem das mesmas classes.","4","7","4","4","10","7","1"
"3","Dado o objetivo que é dado a cada classe acredito que as duas foram coesas com o que pretendiam realizar.  A primeira trata da conexão com o BD e nada mais e a segunda trata da inserção e alteração de dados no BD sendo assim não fazem mais ou além dos objetivos que lhe foram atribuídos.","1","A segunda classe mistura métodos de delete da BD com métodos de busca para preencher combo box, gerenciamento de ocupação dos quartos etc sendo assim pouco coesa, enquanto a primeira realiza apenas a configuração do aquivo.","3","As duas classes fazem um tratamento similar as relações familiares, uma trata no nível marido/mulher e na outra filho  pai/mãe","3","8","4","4","6","3","1"
"1","A linha de comando Class.forName(""com.mysql.jdbc.Driver"") torna a classe menos flexível. É como se a classe estivesse presa ao MySQl.","3","As duas classes tem o mesmo nível de flexibilidade. A diferença é que em uma você tem a robustem de um SGBD para garantir as propriedades ACID e na outra você teria a ""leveza"" de um arquivo XML. Nas duas situações (Banco e arquivo XML) você poderia acesso a informação de maneira estruturada (no banco pelo paradigma relaciona e pela XML usando as tags).","1","A classe RelationSpouse é mais coesa devido a necessidade de utilizar diversos imports.    import java.io.File;  import java.io.FileWriter;  import java.io.IOException;  import java.util.Iterator;    import javax.swing.JOptionPane;","4","9","4","4","12","3","1"
"1","Se analisarmos a coesão sob a perspectiva de que ela é medida de acordo com o relacionamento dos elementos internos, a classe DB_Backend é uma classe mais coesa do que a classe DB_InsertUpdate. Além disso, é mais difícil conseguir decompor esta classe.","1","A classe MainConfig2 é altamente coesa uma vez que seus elementos são altamente relacionados internamente, principalmente nos métodos load_config e save_config. Já a classe DB_Helpers apresenta uma baixa coesão. Além de seus elementos não estarem fortemente relacionados internamente, ela classe pode ser facilmente decomposta em outras classes.","3","Ambas as classes possuem o mesmo nível de coesão. Em ambos os casos o elementos relacionam-se internamente. Além disso, os atributos são utilizados pela maioria dos métodos implementados pela classe, o que indica uma forte coesão.","4","7","3","4","5","3","1"
"1","Backend is harder to split. Both operations Connect and Close are quite bonded to itself, since the DB handle is kept in the class (public static Connection).  The second class, in theory, could be divided into a Inserter and a Updater classes with no harm.","1","DB_Helpers has operations not only related to the DB, but also related to the business logic (related to a rooms availability) whereas the Main_Config2 has operations related to the Config only.","2","RelationSpouse has printing related functionality in it. It should be moved to a Printer class.","3","9","4","4","13","10","1"
"3","A primeira classe deixa claro que seu objetivo é gerenciar a conexão com o banco de dados. Internamente, de fato, seus métodos não fazem nada a mais que isso.    A segunda classe possui apenas métodos para inserir e atualizar registros no banco de dados (BD), que é o objetivo da classe. Contudo, de um lado, e segundo uma das referências anteriores, essa classe poderia ser dividida em duas (DB_Insert e DB_Update) e, por tanto, não estaria tão coesa. Por outro lado, o autor da classe deixou claro que o objetivo da classe é ""escrever"" no BD e, nesse caso, tanto insert quanto update estão dentro desse objetivo. Dessa forma, eu a considera tão coesa quanto a primeira classe.","1","O objetivo da primeira classe é bem definido, o da segunda não é. A segunda classe mistura regras de negócio específicas da reserva de quarto, ao mesmo tempo que fornece um método que delete qualquer tipo d entrada no banco de dados. A mesma poderia ser dividida em duas ou mais classes com objetivos mais específicos.","3","As classes possuem objetivos bem definidos.","4","9","4","4","8","6","1"
"1","A primeira classe não corresponde a sua descrição, pois não manipula a conexão com o banco de dados e sim o pool de conexões. Os atributos e métodos não são completamente coesos, pois misturam a manipulação de uma unica conexão, como login, senha, endereço da base etc, com métodos que dizem respeito a manipulação/criação do conjunto de conexões.    Já a segunda classe mistura características de operações na base de dados e query builder, dessa forma caracterizando a falta de coesão pelo excesso de responsabilidade.","1","A classe DB_Helpers mistura responsabilidades ao manipular elementos como combo box.","2","A classe RelationSpouse tem responsabilidades que não são condizentes com seu contexto. ex: printToFile","3","8","4","4","8","6","1"
"3","The DB_Backend class only contains methods to handle ""connect to DB"" feature.    The DB_InsertUpdate class also handle insert/update the data base so both classes are cohesive. They implement specific functionalists without using other classes. They also focus on specific functionalities.","2","Although the Main_Config2 is acting like a config file but it is better that for different related classes, we use different config class. This class is not cohesive, it contains all information to config DB, Invoice, Billing, storing guest data and so on. So it does not focus on specific functionality.  Helper Class helps to handle the functionalities of DB so it is more cohesive than the Main_config one.","3","Both handles specific functionality.","5","8","4","5","5","1","1"
"1","The members of DB_InsertUpdate are quite unrelated; for DB_Backend, the methods are concerned with fields of the same class.","1","Same as my previous answer: Main_Config2's members heavily use other members of the same class. That's not really the case for DB_Helpers.","3","I don't see substantial differences in the usage pattern of members.","5","7","3","4","10","0","1"
"3","Both classes do what you described they would, and nothing else.  Both classes log exception, which is crosscutting, but since both class do that, I feel they have similiar cohesion.","2","The Main_Config is tangled with fields for the hotel as well as for the database. It could easily be separated in two util classes.","2","RelationSpouse also handles children, but children are not necessary for husband and wife; on the other hand, parents are necessary for children, so the second class is more cohesive","5","4","2","3","7","0","1"
"1","* Class DB_Backend has 3 jobs: connect to the db, disconnect to the db, and track the connection and the connection information.    * DB_InsertUpdate is not actually an OO class, it is a set of functions in a module. If java had modules rather than classes we would put these methods into a module as functions. DB Insert Update does 2 things. Insert is actually quite different than update, although both are relevant to writing.","2","Both classes are pretty terrible for cohesion.    DB_Helpers is a utility class that mixes UI code with model code. It is really quite awful, but it is all relevant to the DB.    Main_Config2 is a smaller class, but its role is 2 fold, it contains DB information and billing information and currency information. I claim it is less cohesive because the distance from UI to Data is shorter than the distance of DB Config to Customer information.    Both are bad.","2","Similar classes but class 1: RelationSpouse couples itself with File IO directly. This is totally unnecessary, a toString() would be alright but FileIO is unweidly and complicated and you probably wanted that string anyways. FileIO is not relevant to a relationship. Immediate string serialization is.","5","9","4","4","20","13","1"
"1","I consider the first class more cohesive.  It only deals with database connections.  The second class deals with two types of db operations: insert, and update.  In this example, the second class might still be considered a cohesive class, but less cohesive relative to the first.","1","I look at the behavior.  The first class has varied data elements, but its behavior can be summarized as load config data, save config data, and retrieve any particular config data item.    The second class has many different behaviors, at multiple layers of abstraction, from db level concerns (getNextId, delEntry) to UI concerns (getComboItems) to business level operations (getNumberRooms).","2","The printToFile class in RelationSpouse does not belong.  It is not behavior that is related to the relationship.","4","8","4","4","15","15","1"
"3","It is quite difficult to assess the cohesion of a class by itself and with as little context as is provided in this question. That being said, none of the two classes are clearly non-cohesive (both have a clear purpose and the functionalities included in each are indeed conceptually related). Beyond that, very little can be said.","3","Very little can be said without further context. These both seem like utility classes, and they do have clearly defined functionality.","2","Now these, since they are very similar, I can make a judgment about. THe first class is more cohesive since the relationSpouse has a method related to printing its information to file, but relationParentChild does not.   That being said, I do not necessarily thin that it is wrong to include the print method in relationParentChild. THough it is less cohesive, it might be a good decision to put the print method inside this class. More context is needed (i.e. are all other Relation classes similar to Spouse or to ParentChild). I favor consistency over any metric such as cohesion.","4","10","5","5","15","5","1"
"1","The responsibility for the DB_Backend class was clear to me; as the name of the class implies, it keeps and manages the lifecycle of some connections to a database in the backend.    On the other hand, the second class seems to have no responsibility; it has no attribute and only contains some static methods. This class is just a placeholder for these utility methods (or functions, since they have no side effects to the class). The class might never be instantiated.","1","The first class, Main_Config2, its responsibility was clear to me; a instance of this class holds configuration settings for the system and provides methods for serializing/deserializing those information to/from an XML file.  I prefer to split the responsibility to following three parts: 1) holding hotel information, 2) holding database information, 3) serialization and deserialization.    As for the second class, DB_helpers, it is again a static utility class and its responsibility is ambiguous to me. Some concerns are overlapped; The fist three methods, getNextID and two delEntry, are utilities to wrap SQL queries in a table-independent way. Following two methods, getComboItems and getListItems, populates items into GUI models by querying the database. Remaining three methods, isRoomDeletable, getReservedRoomsAtDate and getNumberOfRooms encapsulates queries to specific tables in the database.","2","The second class contains a single responsibility to maintain parent-child relationship between domain objects. On the other hand, the first class, RelationSpouse, has extra responsibilities to report exceptions on a GUI widget and dump debug information in addition to the basic responsibility that maintains spouse relationship between domain objects.     Comparing objects using reference equivalence (==) in RelationParentChild#isParent() and #isChild() considered to be buggy, although I know this is not relevant to the survey.","5","8","5","5","18","10","1"
"3","Ambos estão resolvendo um problema específico.    Mas existe problemas graves de:   - repetição de código   - DB_InserUpdate depende de DB_Backend ( Deveria usar a Injeção de Dependência e Segregação de Interface)   - DB_Backend depende do MySQL ( Deveria usar a Injeção de Dependência e Segregação de Interface)","1","O Main_Config2 está muito duas responsabilidades:   - Ler/Escrever arquivo de configuração   - Fazendo papel de Entity    O DB_Helpers está com muitas responsabilidades, até mesmo para uma classe Helper.","2","A RelationSpouse está com muita responsabilidade. Ela não deveria escrever em arquivo e também não deveria ser responsável pela View.    Eu não modificaria o RelationParentChild.","4","8","4","4","10","4","1"
"1","In my opinion the DB_Backend is a bit more cohesive than DB_InsertUpdate but not by much. Both classes are very easy to understand. However, DB_Backend seems a bit more cohesive because all the fields (conns, con_pool, Host, etc.) and all the methods (DB_Backend, init, connect_DB, etc.) implementing this database backend functionality are inside the class. On the other hand, the DB_InsertUpdate class does not have everything “encapsulated” in that class, and is also implementing 2 related (but slightly different) concepts: insert and update.","1","These 2 classes implement “miscellaneous” functionality. The first one (Main_Config2) deals with all the configuration settings (language, hotel information, database, billing policies, etc.) and the second one (DB_Helpers) deals with various operations on the database (delete entries, get number of rooms, etc.). These classes are not as cohesive as the previous 2 classes (DB_Backend and DB_InsertUpdate). However, in my opinion Main_Config2 is slightly more cohesive than DB_Helpers because DB_Helpers implements functionality from the solution domain (deleting entries in the table) as well as problem domain (get number of rooms), whereas Main_Config2 only deals with the settings (however diverse they are).","2","These 2 classes are almost equally cohesive. However, the RelationParentChild class seems to be a bit more cohesive than the RelationSpouse because the RelationSpouse class has the method printToFile(File f) which deals with Input/Output functionality, and which is not coherent with the remaining fields and methods of the class that deal with “relation” issues.","5","10","5","5","14","7","1"
"3","Each class is specialize to a behavior (connexion vs. update)","2","The first one Main_Config2 merge both hotels data and database data  The second one have only information to help the sue of database","1","Bith classes have a problem with the method getPartner(). I think it is a method for Person.  The class RelationParentChild is more cohesive because of the method printToFile() in the class RelationSpouse that make it less cohesive","5","4","4","4","3","1","2"
"1","DB_Backend class encapsulates data for a database connection and provides methods for the connection.  DB_InsertUpdate class provides only functions.  The static methods could be integrated in other DB access class, e.g. DB_Backend.","1","The methods in Main_Config2 provide access to a program configuration, though the actual data members may be not related to each other.  Some methods in DB_Helpers are not related to each other, and they are located in DB_Helpers because they are just helper methods.","2","This is the difficult question, but printToFile method in RelationSpouse class may be located in another class that defines a format of textual output.","5","6","3","4","15","3","1"
"1","A primeira classe lida, em sua maior parte, com atributos definidos na própria classe. Além disso, é possível perceber claramente que a classe representa um conceito (gerenciamento de conexões com BD). Isso ajuda na leitura e entendimento da classe.    Por outro lado, a segunda classe já possui de cara um indício de que não é coesa: não possui nem um atributo e possui métodos grandes que utilizam métodos de várias outras classes.","1","O cenário é parecido com o anterior. O agravante da segunda classe é que ela disponibiliza métodos que não parecem ter relações com um único conceito, ou seja, métodos não relacionados. Por exemplo, essa mesma classe lida com conceito de ID, com o gerenciamento de quartos etc    Por outro lado, é simples dizer o que a primeira classe faz - lida com a configuração do sistema. Perceba que os métodos dessa classe acessam/modificam quase que unicamente os atributos dessa própria classe.","2","A segunda classe é mais coesa que a primeira. A primeira classe, além de lidar com seus atributos e possuir métodos que lidam com as relações marido-esposa, possui um método para imprimir em um arquivo os dados. Para mim, isso afeta a coesão, pois a classe lida com mais de um conceito (relação marido-esposa e persistencia de dados).","4","8","4","5","8","4","1"
"3","Verifiquei se as classes fazem o que foram criadas para fazer, sem extender suas responsabilidades, e na minha opinião ambas são coesas.","1","A primeira classe possui um papel bem definido, enquanto a segunda realiza diversas operações de banco, tanto de persistência quanto de consulta, além de realizar consultas a tabelas específicas, quando sua função proposta era de ser uma classe utilitária. Os métodos de consulta a tabelas específicas deveriam estar em classes criadas especificamente para acesso a estas tabelas.","2","A segunda classe possui alta coesã, enquanto a primeira extrapola suas responsabilidades ao realizar envio de mensagens de alerta e gravação em arquivos.","1","6","3","3","4","4","1"
"3","Because the methods belonging to each of the two classes seems to be very particular to the intention described below","1","Considering there is a class dedicated to only updating the database, the same can be done to delete or get information from the database. In other words, BD_Helpers can be separated in a class for only queries and another for only deleting.  However, I don't understand why a configuration needs all that info, why database info must be with name, phone, etc.","1","The RelationParentChild seems to be recycled from the other class. Why there is a methods called ""getPartner"", the intention is not clear.   Besides, both class have methods called ""getPerson1"" and ""getPerson2"" which does not make a lot of sense.","2","7","3","4","5","1.5","1"
"3","Based on the class name and its method names, both classes look like their methods should be included in those classes and no in any other class.","3","The first class (Main_Config2) can be separated in two classes (one to set, another to get). The other class looks like is just a class that has been used to put methods related to a DB that do not fit anywhere else.","3","Given that both classes have similar functionality (to find out the relation between two relatives), and the methods are similar, I decided to determine that both classes have similar cohesion.","4","8","4","4","7","4","2"
"1","Although the design of the first class might not be considered optimal, it at least provides higher cohesion than the second. That is because the private fields of the class are used for database connectivity from all the methods. And the responsibility of the class is driver-level database connectivity. However, it should be noted that it mixes in Messaging, JOptionPane and Logging calls. These are cross-cutting concerns. At the very least, the class should use one single method of providing messages or errors, and not a mixed bunch of different calls to different classes. That responsibility is better suited to be in the caller of the class.    The second class, on the other hand, provides only static methods that do not share any code or fields and also contain similar/duplicate lines. They also represent two responsibilities: Insert and Update. It can therefore be split easily into two classes.","1","Again, the first class is more cohesive. It provides access to the system configuration, serving the role of a kind of &quot;Configuration Manager&quot;. The private fields are reused in different methods and the common responsibility of the class is very clearly cut.    The second class is just a random collection of helpful methods, that mostly do not have any contextual similarities in their responsibilities. Their code is probably much better suited to be put into classes that are responsible for the respective tasks, e.g. a &quot;DeleteEntryCommand&quot;.","2","Here, both classes contain the code for a specific relation, which is correctly specified in both cases. The only difference is, that the first class is actually mixing other code into its behavior (like the JOptionPane calls), which has nothing to do with its intended responsibility (which I think should be just the representation of a relationship).    Thus, the second class is more coherent, because it does not mix in different concerns like the display of messages.","4","8","4","5","7","2","1"
"1","Porque a segunda classe DB_InsertUpdate precisa da primeira DB_Backend para funcionar","1","Na primeira clase Main_config2 eu nao consegui identificar o uso de outras classes  Na segunda classe DB_Helpers eu percebi que ela usa a classe DB_Backend","3","Ambas são subclasses de Relation","4","8","4","4","15","15","1"
"3","Todos os métodos e propriedades das classes dizem respeito ao problema que elas foram destinadas a resolver. Apesar de achar estranho uma modelagem que dedica uma classe apenas para gerenciar conexões e outra apenas para cuidar de inserções e atualizações no banco de dados, não me parece que a coesão das mesmas foi afetada.","1","Na minha opinião a primeira classe é coesa pois se restringe apenas a carregar parâmetros gerais de configuração do software, e manipular esses parâmetros internamente (métodos get e set). Por outro lado, a segunda classe perde coesão a partir do momento em que funções que lêem informações do banco de dados se misturam com funções que manipulam os formulários utilizados na interface do usuário.","2","Neste caso a segunda classe é mais coesa do que a primeira, pois enquanto que a primeira classe mistura métodos destinados a manipular arquivos em disco com métodos que tratam do relacionamento marido/mulher (responsabilidade principal da classe), a segunda trata APENAS do relacionamento pais/filhos, mantendo assim a sua coesão.","4","8","4","4","15","0","1"
"2","a primeira se propõe a manusear a conexão com o banco de dados estando inclusas aí as atividades de abertura, fechamento e recuperação de uma conexão. já a segunda somente atualiza o estado do banco de dados.","1","apesar da classe Main_Config2 apresentar 2 operações (save_config() e load_config()) distintas do seu propósito inicial de setar  e recupear parâmetros de configuração a classe DB_Helpers apresenta operações de contextos muito distintos de um do outro (get_nextID(), del_entry(), getListItems(), etc.). em outras palavras,  a primeira diz respeito somete à configuração enquanto a segunda contém operações genéricas em tabelas bem como relacionadas a booking ou ainda a rooms.","1","ambas as classes apresentam métodos semelhantes, aparentemente herdados da classe Relation. no entanto a classe RelationSpouse tem um método que caiu do céu para salvar salvar em arquivo.","4","6","3","4","6","0","1"
